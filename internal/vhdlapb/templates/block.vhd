-- This file has been automatically generated by the afbd tool.
-- Do not edit it manually, unless you really know what you do.
-- https://github.com/Functional-Bus-Description-Language/afbd

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

library ltypes;
  use ltypes.types.all;

library work;
  use work.apb.all;


package {{.EntityName}}_pkg is

-- Constants
{{.Constants}}
-- Proc types
{{.ProcTypes}}
-- Stream types
{{.StreamTypes}}
end package;


library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

library lapb;
  use lapb.apb;

library ltypes;
  use ltypes.types.all;

library work;
  use work.apb.all;
  use work.{{.EntityName}}_pkg.all;

{{ if or (gt .MasterCount 1) (gt .SubblockCount 0) }}
-- The SYNC_ADDR_DECODING generic determines whether the address decoder should be synchronized
-- to the clock edge. If not synchronized, the whole transaction is shorter by one clock
-- cycle (lower latency). However, in case of multiple requesters and completers, there might
-- be timing closure problems.{{ end }}
entity {{.EntityName}} is{{ if or (gt .MasterCount 1) (gt .SubblockCount 0) }}
generic (
  SYNC_ADDR_DECODING : boolean := true
);{{ end }}
port (
  clk_i : in std_logic;
  rst_i : in std_logic;
  apb_coms_i : in  apb.completer_in_array_t (0 to {{.MasterCount}} - 1);
  apb_coms_o : out apb.completer_out_array_t(0 to {{.MasterCount}} - 1){{.EntitySubblockPorts}}{{.EntityFunctionalPorts}}
);
end entity;


architecture rtl of {{.EntityName}} is

constant C_ADDRS : apb.addr_array_t(0 to {{.SubblockCount}}) := ({{.AddressValues}});
constant C_MASKS : apb.mask_array_t(0 to {{.SubblockCount}}) := ({{.MaskValues}});

signal apb_req : apb.requester_out_t;
signal apb_com : apb.completer_out_t;

{{.SignalDeclarations}}
begin

{{ if and (eq .MasterCount 1) (eq .SubblockCount 0) }}
apb_req <= apb_coms_i(0);
apb_coms_o(0) <= apb_com;
{{ else }}
Shared_Bus: entity lapb.Shared_Bus
generic map (
  REPORT_PREFIX   => "apb: shared bus: {{.EntityName}}: ",
  REQUESTER_COUNT => {{.MasterCount}},
  COMPLETER_COUNT => {{.SubblockCount}} + 1,
  ADDRS => C_ADDRS,
  MASKS => C_MASKS,
  SYNC_ADDR_DECODING => SYNC_ADDR_DECODING
) port map (
  arstn_i => not rst_i,
  clk_i   => clk_i,
  coms_i  => apb_coms_i,
  coms_o  => apb_coms_o,
  reqs_i(0) => apb_com,{{.CrossbarSubblockPortsIn}}
  reqs_o(0) => apb_req{{.CrossbarSubblockPortsOut}}
);
{{ end }}

register_access : process (clk_i) is

-- Internal register address, not byte address.
variable addr : natural range 0 to {{.RegCount}} - 1;

begin

if rising_edge(clk_i) then

-- Normal operation.
-- Currently the block is implemented in such a way that it is always ready.
apb_com.ready <= '1';
apb_com.slverr <= '0';

-- Procs Calls Clear{{.ProcsCallsClear}}
-- Procs Exits Clear{{.ProcsExitsClear}}
-- Stream Strobes Clear{{.StreamsStrobesClear}}

transfer : if apb_req.selx = '1' then
{{ if gt .InternalAddrBitCount 0 }}
  -- Shift by 2 bits because of byte addressing.
  addr := to_integer(unsigned(apb_req.addr({{.InternalAddrBitCount}} - 1 + 2 downto 2)));
{{ else }}
  -- There is only one register in the block, fix address to 0.
  addr := 0;
{{ end }}

  -- First assume there is some kind of error.
  -- For example internal address is invalid or there is a try to write status.
  apb_com.slverr <= '1';
  -- '0' for security reasons, '-' can lead to the information leak.
  apb_com.rdata <= (others => '0');

  -- Registers Access{{range $addr, $code := .RegistersAccess}}
  if {{$addr.Start}} <= addr and addr <= {{$addr.End}} then
{{$code}}

    apb_com.slverr <= '0';
  end if;
{{end}}

  -- Proc Calls Set{{.ProcsCallsSet}}
  -- Proc Exits Set{{.ProcsExitsSet}}
  -- Stream Strobes Set{{.StreamsStrobesSet}}

end if transfer;

if rst_i = '1' then
  apb_com.slverr <= '0';
end if;
end if;
end process register_access;


-- Combinational processes
{{.CombinationalProcesses}}

end architecture;
